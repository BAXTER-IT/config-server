<?xml version="1.0" encoding="UTF-8"?>
<document xmlns="http://maven.apache.org/XDOC/2.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

	<properties>
		<title>Features</title>
		<author email="ykryshchuk@n-ix.com.ua">Yuriy Kryshchuk</author>
	</properties>

	<body>

		<section name="Features">
			<p>The following list has to be reviewed and approved. </p>
			<p>
				<map id="feature-map">
					<table>
						<caption>Features map (Phase 1)</caption>
						<thead>
							<tr>
								<th>#</th>
								<th>Description</th>
								<th>Effort</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<a href="http://jira.baxter.com/jira/browse/CONF-2">CONF-2</a>
								</td>
								<td><b>Configuration has to be persisted on local file
									system.</b><br/> In order to simplify the first iteration step
									we do not introduce any kind of advanced storage for
									configuration source. All configuration source files has to be
									stored in one place on configuration server. That, however,
									shold not be a single file nor just one directory. It should be
									rather a set of files and subdirectories under one well defined
									root directory. All configuration sources will be persisted
									there and will be read by configuration application for further
									processing. The only way to manage the configuration by
									administrator will be the manual editing of files on
									configuration server file system. </td>
								<td>1d</td>
							</tr>
							<tr>
								<td> </td>
								<td><b>Define persistence schema (files format and layout).</b><br/>
									<p>This feature set defines the schema for files persistence on
										configuration server. The configuration source will be
										distributed among a well defined set of source files, that
										will be read and processed at runtime. The files must
										conform to a defined format, which will be easy to maintain
										by administrators and easy to read and process by
										application. The files layout should simplify the algorithms
										of composing single response file for clients from the set
										of source files.</p>
									<p>One of proposed ideas is to keep all the configuration in XML
										formats. This should give the benefit when processing this
										input. Using the XSLT the input XML can be converted to any
										other format.</p>
								</td>
								<td>3d</td>
							</tr>
							<tr>
								<td> </td>
								<td><b>Tagging configuration sources.</b><br/> The mechanism that
									allows to compose different configuration sources into the
									single file to be delivered to client. Many configuration
									details will be exactly the same for different components, but
									there will be also individual configurations that are meaningful
									only for particular application. In order to simplify automated
									processing of configuration source we have to develop the
									tagging strategy so the application can choose granular
									configurations to be composed for a particular requesting
									component.</td>
								<td>1d</td>
							</tr>
							<tr>
								<td> </td>
								<td><b>Support for license file (constants.xml).</b><br/> The
									license file should not be distributed with PE binaries. The
									license is a part of PE environment, so it will be persisted on
									configuration server. All PE components will request this file
									upon startup for further processing. On the first phase the file
									has to be stored manually on the filesystem by administrator (as
									defined by configuration store layout). On later phases the
									Management UI will provide an instrument to upload the
									file.</td>
								<td>1d</td>
							</tr>
							<tr>
								<td> </td>
								<td><b>Support for Log4J Configuration.</b><br/> Configuration
									Server should be able to deliver the Log4J configuration files
									per client requests. These files will be requested once upon
									application start. The server must be able to deliver different
									logging configurations for different components. In order to
									support the maximum of flexibility provided by Log4J
									Configuration, the server must keep original log4j.xml files for
									components and apply very limited modification to those when
									serving responses to clients. This means that configuration
									managers will be able to use all of the features available for
									Log4J configuration when editing the source files on server file
									system. We can define, however, some recommendations to follow
									when adjusting log4j files which later will be strictly applied
									by an automated management UI, for example, all file appenders
									should define relative paths to target log files, like
										<code>log/myfile.log</code>, having assumed that application
									will always start with PE Home as working directory. Another
									sample of a recommendation would be using of ASYNC appenders
									(that redirect to File Appenders) which may improve the logging
									in multithreaded application.</td>
								<td>2d</td>
							</tr>
							<tr>
								<td> </td>
								<td><b>Support for Logback Configuration.</b><br/> This requirement
									is very similar to <b>Support for Log4J Configuration</b>. The
									purpose is to provide the configuration for clients which run
									with logback implementation. The difference between logback and
									log4j configuration is not significant, so both can be generated
									on the fly (for instance with XSLT) from the same source. For
									this reason we have to define the logging configuration source
									format. </td>
								<td>1d</td>
							</tr>
							<tr>
								<td> </td>
								<td><b>Support for properties.xml files.</b><br/> Price Engine
									components require their own configuration with a format
									referenced as <code>properties.xml</code>. This format in
									general allows to organize settings in a hierarchy as XML. There
									are entries, references to entries and groups of entries. This
									format is used in PE components to describe the JMS environment
									(instances, access to instances and channels on these instances)
									and some values specific for application components.
									Configuration server should be able to deliver the correct
									content for properties configuration depending on the request,
									e.g. proper set up for a particular component. </td>
								<td>3d</td>
							</tr>
							<tr>
								<td> </td>
								<td><b>Support for plugins configuration.</b><br/> There is wide set
									of configurations for Broadcast plugins. This includes such
									formats as java properties, ini, xml and binary files. Some of
									the configurations are accessed and read directly by Broadcast
									plugin code and some are delegated to third party libraries.
									Independent on how the configuration file will be used it should
									be stored on configuration server and then delivered to
									requesting broadcast application. The application may use same
									strategy to get these files and optionally persist them locally
									(secondary cache) to deliver to 3-rd party code. The central
									point of configuration for plugins is PE database table which
									references the files via paths on file system. This shall be
									changed in a way that database points to some coordinates or IDs
									of configurations.</td>
								<td>4d</td>
							</tr>
							<tr>
								<td> </td>
								<td><b>Configuration references.</b><br/> In order to satisfy the
									dependencies between configurations we will need a mechanism to
									reference configurations. For instance, plugins configurations
									depend on several configuration files as xmls, ini or binaries
									(like certificates). Instead of defining the file paths for such
									dependencies we can use a sort of configuration references, so
									one configuration file will point to other configuration that
									has to be loaded from config server. </td>
								<td>1d</td>
							</tr>
							<tr>
								<td> </td>
								<td><b>Configuration variants (inheritance).</b><br/> Allows
									creating variants of a configuration with modified base
									settings. The same applciation may have slightly modified
									settings dependning on several conditions - it may run on other
									hardware, it may serve different clients etc. But in general all
									instances of the same application share some common
									configuration. The configuration variants will help to define
									some basis set up and also provide the modified or extended
									setup for such variants. The exact configuration variant will be
									denoted by a configuration id that includes an advanced variant
									identifier.</td>
								<td>2d</td>
							</tr>
							<tr>
								<td>
									<a href="http://jira.baxter.com/jira/browse/CONF-1">CONF-1</a>
								</td>
								<td><b>The configuration client API (Facade)</b><br/> The goal of
									this API is to provide an easy and unified instrument for PE
									components which allows reading the remote configuration at
									runtime. This API will allow easy integration with configuration
									server. </td>
								<td>3d</td>
							</tr>
							<tr>
								<td> </td>
								<td><b>Rest Servlet.</b><br/> This is a main feature of
									configuration server. The servlet will be the only entry point
									for configuration clients to get the configuration. Servlet will
									follow the restful approach, where each entity (configuration)
									is accessed by well defined URL with optional parameters.
									Servlet will listen for client configuration requests, determine
									which configuration and for which component is requested, then
									build the configuration and deliver it.</td>
								<td>2d</td>
							</tr>
							<tr>
								<td> </td>
								<td><b>Configuration identification (request protocol).</b><br/> The
									schema of configuration ID to be used for Rest requests. All
									possible configuration entities (files) can be uniquelly
									identified. There are several possible final categorization
									ways: type of configuration (logging, PE properties etc),
									configuration by component and variant. There will be exactly
									one possible content to deliver according to the configuration
									request. </td>
								<td>2d</td>
							</tr>
							<tr>
								<td> </td>
								<td><b>Configuration compatibility (versioning).</b><br/> In order
									to handle the configuration format changes, the request protocol
									must consider the configuration versions. There are two possible
									approaces to use. <ul>
										<li>Client may request a configuration with some required
											version. If server does not support this version, the
											server will return an error.</li>
										<li>Client requests the configuration and server returns the
											version of it. The Client decides whether the provided
											version is fine for it.</li>
									</ul> Configuration request protocol can be implemented in a way
									to support both approaches. <p> There are also some risks
										related to versions compatibility which are not
										configuration specific. The changes can be said as backward
										compatible, if the newer version of configuration is
										completely supported by client (just some information will
										be lost). There are also backward incompatible changes, for
										instance, the element attribute has been renamed... </p>
								</td>
								<td>1d</td>
							</tr>
							<tr>
								<td> </td>
								<td><b>Support for Development mode.</b><br/> In order to speed up
									and simplify the development the configuration client API must
									provide a way to run applications in development mode, e.g.
									without the running configuration application. In this case the
									configuration will be delivered from the local filesystem. This
									option still has to be investigated, as the configuration server
									does not require alot of resources and it can be easily run on
									development environment.</td>
								<td>4d</td>
							</tr>
						</tbody>
					</table>
				</map>
				<map id="feature-map-2">
					<table>
						<caption>Features map (Phase 2)</caption>
						<thead>
							<tr>
								<th>#</th>
								<th>Description</th>
								<th>Effort</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td/>
								<td><b>Support for VM/GC configuration.</b><br/> The reason for this
									feature is to have a centralized overview of JVM setup. Each JVM
									instance for particular applciation can be configured at one
									place and then this configuration will be read by an
									"application launcher" to start java process. That can be either
									a small separate launcher application or a start script. </td>
								<td/>
							</tr>
							<tr>
								<td> </td>
								<td><b>Configuration object model.</b><br/> The purpose of creating
									the configuration object model is to simplify the maintenance
									and validation of different configuration sources in management
									UI application. It should be implemented using the pluggability
									approach, e.g. Price Engine will provide object model for PE
									specific settings, and other products will provide their own.
									This may be useful on the configuration facade layer, which will
									bring some benefits on processing the remote configuration
									without need to parse it. </td>
								<td/>
							</tr>
							<tr>
								<td> </td>
								<td><b>Configuration revisions.</b><br/> This feature is not
									targeted to the first iteration step. In general we can provide
									the configuration versioning by embedding some VCS into the
									configuration server. On the first phase the configuration
									administrator will be responsible for backing up files.</td>
								<td/>
							</tr>
							<tr>
								<td> </td>
								<td><b>Configuration access security.</b><br/> Possibility to filter
									the clients requests to different configurations. For instances,
									we might restrict access to database configuration from
									broadcast application. As this is not a trivial (but still
									doable) task to restrict the access to the same servlet for
									different clients, the task can be done using the advanced
									security mechanisms of Apache server (which will be typically
									used as a wrapper for Tomcat or JBoss container hosting the
									configuration web application). </td>
								<td/>
							</tr>
							<tr>
								<td> </td>
								<td><b>Graphical Management UI.</b><br/> Postponed to next phase as
									it requires an effort to implement UI.</td>
								<td/>
							</tr>
							<tr>
								<td> </td>
								<td><b>Access roles to Management UI.</b><br/> Postponed to next
									phase as it depends on <b>Graphical Management UI</b>.</td>
								<td/>
							</tr>
							<tr>
								<td> </td>
								<td><b>Configuration of JMS nodes.</b><br/>
									<p>The configuration for JMS Provider (e.g. SwiftMQ) should be
										specified with Configuration server. This will require
										integration of Baxter Config with start scripts of JMS.</p>
									<p>Still has to be investigated.</p></td>
								<td/>
							</tr>
							<tr>
								<td> </td>
								<td><b>Hosting of external configurations</b><br/>
									<p>Baxter Configuration should provide an instrument to host
										external configurations to be served for other than PE
										applications.</p>
									<p>(using Config Client API?)</p></td>
								<td/>
							</tr>
						</tbody>
					</table>
				</map>
			</p>
		</section>

	</body>

</document>
